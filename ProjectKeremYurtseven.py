## Communication Engineering Project
##
## Author     : Kerem Yurtseven - kerem.yurtseven@boun.edu.tr
## Number     : 2020401174
##
## University : Boğaziçi University
## Department : Electrical and Electronics Engineering
## Course     : EE371 - Communication Engineering
## Instructor : Prof. Ali Emre Pusane
## T.A        : Uzay Bengi
##
## Subject    : Design a pulse code modulator and delta modulator of a given signal m(t)
## Date       : 05.01.2024


# Libraries
import numpy as np
import matplotlib.pyplot as plt

# Define a discrete time generator for sampling
def samplingTime(duration, frequency):
    return np.arange(duration*frequency)/frequency


# Define a discrete sine signal generator
def signal(amplitude, frequency, time, phase):
    return amplitude * np.cos(2*np.pi*frequency*time + phase)


# Pulse Code Modulation (Assume any level x include voltage levels between (interval*x, interval*(x+1)]. Lowest level include also the lower limit. Highest level has label 0 and lowest level has label 63)
def pulseCodeMod(signal, levels, minValue, maxValue, time):

    bits = int(np.ceil(np.log2(levels)))   # Bits needed to represent number of levels on binary
    interval = (maxValue-minValue) / levels        # Interval of each level 

    pulseCode = list()   # Empty list

    for i,t in enumerate(time):
        corrLevel = int(np.floor((maxValue-signal[i])/interval))   # Decide which interval the given signal sample corresponds
        binaryLevel = np.binary_repr(corrLevel, width=bits) if corrLevel <= levels else np.binary_repr(levels, width=bits)   # If the sample is equal to or lower than minimum value of the signal, choose corresponding level as the maximum level 
        pulseCode.append(binaryLevel)

    return pulseCode


# Delta Modulation
def deltaMod(signal, stepSize, time):

    delta = np.zeros_like(signal, dtype=int)   # Zero array with shape of the given signal

    sumofDeltas = np.sum(delta) * stepSize   # Signal sample can be compared to this value as the nature of differential pulse code modulation. This formula's theoratical derivation is mq[k] = ∑dq[m] with the assumption of mq[0] = 0. However, not in all case mq[0] = 0, which results in more or less overload based on the starting value.

    for i,t in enumerate(time):
        if signal[i] > sumofDeltas:   # Compare the value of signal sample with value generated by delta modulation. If value is greater than delta is 1, if value is equal to delta it stays same by assuming the propability of continuing same pattern is high, else delta is equal to -1
            delta[i] = 1
        elif signal[i] == sumofDeltas:
            delta[i] = delta[i-1]
        else:
            delta[i] = -1
        sumofDeltas = np.sum(delta) * stepSize

    for i,t in enumerate(time):
        delta[i] = 0 if delta[i] == -1 else delta[i]
    
    return delta


# Signal given in project is m(t) = -cos(250πt) + sin(70πt)
# It is sum of two signals: former with amplitude -1V, frequency 125Hz, phase 0 rad and latter with amplitude 1V, frequency 35Hz, -phase π/2 rad



## PROEJCT TASK 1
# Project task 1 desire to modulate signal between t=(0,2) and sampling frequency is 1.5*Nyquist Frequency. Nyquist frequency is 2*Highest frequnecy of the signal
# Given signal has two frequency components: 125Hz and 35Hz. Therefore, Nyquist frequnecy is 250Hz and sampling frequency is 375Hz

timePCM = samplingTime(2, 375)

signalPCM1 = signal(-1, 125, timePCM, 0)
signalPCM2 = signal(1, 35, timePCM, -np.pi/2)

messagePCM = signalPCM1 + signalPCM2

# Quantization levels are given as 64. Highest amplitude of the message signal is 1.9982v and lowest amplitude is -1.9982v, so the amplitude gap is 3.9964v.

modulatedMessagePCM = pulseCodeMod(messagePCM, 64, -1.9982, 1.9982, timePCM)

for i in range(10):
    print(modulatedMessagePCM[i], end="-") if i != 9 else print(modulatedMessagePCM[i])


## PROJECT TASK 2
# Project task 2 desire to modulate signal between t=(0,2) and sampling frequency is 6*Nyquist Frequency. Nyquist frequency is 2*Highest frequnecy of the signal
# Given signal has two frequency components: 125Hz and 35Hz. Therefore, Nyquist frequnecy is 250Hz and sampling frequency is 1500Hz

timeDM = samplingTime(2, 1500)

signalDM1 = signal(-1, 125, timeDM, 0)
signalDM2 = signal(1, 35, timeDM, -np.pi/2)

messageDM = signalDM1 + signalDM2

# Step size can be choosen according to prevent slope overload and minimze granual noise. That is achieved by choosing step size as the minimum number providing amplitude of derivative m(t) < step size*Fs
# Derivative of m(t) = 250π*sin(250πt) + 70π*cos(70πt). So, the max amplitude of derivative of m(t) is 1004.885 V. Choose step size as 1004.885/1500 V/Hz.

stepSize = 1004.885/1500 # V/Hz

modulatedMessageDM = deltaMod(messageDM, stepSize, timeDM)

for i in range(20):
    print(modulatedMessageDM[i], end="-") if i != 19 else print(modulatedMessageDM[i])


# Slope overload can be seen by delta modulation output where there exist repeated sequences of 0s or 1s. It can also be decided whether step size is enough to follow slope by checking graphs. For the chosen step size,
# there exist a starting overload and few small slope overloads. However, for the interval (0,2) there is not a lot of slope overload, so step size is enough. To eradicate more of the slope overload, step size may be increased
# more, yet this will also increase the noise. Increasing frequency is a good choice for a more ideal modulation, but it requires more bandwith.  

# Code to visualize message signal vs DM modulated signal
""" modulatedMessage = np.zeros_like(messageDM)
for i,t in enumerate(timeDM):
    modulatedMessage[i] = stepSize * (np.count_nonzero(modulatedMessageDM[:i+1] == 1)-np.count_nonzero(modulatedMessageDM[:i+1] == 0))

plt.plot(timeDM, messageDM, 'r')
plt.plot(timeDM, modulatedMessage, drawstyle='steps-post', color='g')
plt.axis([0,.014,-2,2])
plt.show() """
